Grammar Rules:
0: <tiger-program> --> LET <declaration-segment> IN <stat-seq> END 
1: <declaration-segment> --> <type-declaration-list> <var-declaration-list> <funct-declaration-list> 
2: <type-declaration-list> --> NULL 
3: <type-declaration-list> --> <type-declaration> <type-declaration-list> 
4: <var-declaration-list> --> NULL 
5: <var-declaration-list> --> <var-declaration> <var-declaration-list> 
6: <funct-declaration-list> --> NULL 
7: <funct-declaration-list> --> <funct-declaration> <funct-declaration-list> 
8: <type-declaration> --> TYPE <id> EQ <type> SEMI 
9: <type> --> <type-id> 
10: <type> --> ARRAY INTLIT OF <type-id> 
11: <type> --> ID 
12: <type-id> --> INT 
13: <type-id> --> FLOAT 
14: <var-declaration> --> VAR <id-list> COLON <type> <optional-init> SEMI 
15: <id-list> --> ID <id-list-tail> 
16: <id-list-tail> --> COMMA <id-list> 
17: <id-list-tail> --> NULL 
18: <optional-init> --> NULL 
19: <optional-init> --> ASSIGN <const> 
20: <funct-declaration> --> FUNC ID LPAREN <param-list> RPAREN <ret-type> BEGIN <stat-seq> END SEMI 
21: <param-list> --> NULL 
22: <param-list> --> <param> <param-list-tail> 
23: <param-list-tail> --> NULL 
24: <param-list-tail> --> COMMA <param> <param-list-tail> 
25: <ret-type> --> NULL 
26: <ret-type> --> COLON <type> 
27: <param> --> ID COLON <type> 
28: <stat-seq> --> <stat> <stat-seq-tail> 
29: <stat-seq-tail> --> NULL 
30: <stat-seq-tail> --> <stat-seq> 
31: <stat> --> IF <expr> THEN <stat-seq> ELSE <stat-seq> ENDIF SEMI 
32: <stat> --> WHILE <expr> DO <stat-seq> ENDDO SEMI 
33: <stat> --> FOR ID ASSIGN <expr> TO <expr> DO <stat-seq> ENDDO SEMI 
34: <stat> --> BREAK SEMI 
35: <stat> --> RETURN <expr> SEMI 
36: <stat> --> LET <declaration-segment> IN <stat-seq> END 
37: <stat> --> <lvalue> <stat-id> 
38: <stat-id> --> LPAREN <expr-list> RPAREN SEMI 
39: <stat-id> --> ASSIGN <stat-tail> SEMI 
40: <stat-tail> --> <expr_not_starting_with_id> 
41: <stat-tail> --> ID <expr_not_starting_with_id> 
42: <expr_not_starting_with_id> --> <not_id_expr_start> <Cterm-tail> <Bterm-tail> <Aterm-tail> <expr-tail> 
43: <not_id_expr_start> --> CONST 
44: <not_id_expr_start> --> LPAREN <expr> RPAREN 
45: <expr_or_func_tail> --> LPAREN <expr-list> RPAREN 
46: <expr_or_func_tail> --> <lvalue-tail> <Cterm-tail> <Bterm-tail> <Aterm-tail> <expr-tail> 
47: <expr> --> <Aterm> <expr-tail> 
48: <expr-tail> --> AND <Aterm> 
49: <expr-tail> --> OR <Aterm> 
50: <expr-tail> --> NULL 
51: <Aterm> --> <Bterm> <Aterm-tail> 
52: <Aterm-tail> --> EQ <Bterm> 
53: <Aterm-tail> --> NEQ <Bterm> 
54: <Aterm-tail> --> LESSER <Bterm> 
55: <Aterm-tail> --> GREATER <Bterm> 
56: <Aterm-tail> --> LESSEREQ <Bterm> 
57: <Aterm-tail> --> GREATEREQ <Bterm> 
58: <Aterm-tail> --> NULL 
59: <Bterm> --> <Cterm> <Bterm-tail> 
60: <Bterm-tail> --> PLUS <Cterm> 
61: <Bterm-tail> --> MINUS <Cterm> 
62: <Bterm-tail> --> NULL 
63: <Cterm> --> <factor> <Cterm-tail> 
64: <Cterm-tail> --> MULT <factor> 
65: <Cterm-tail> --> DIV <factor> 
66: <Cterm-tail> --> NULL 
67: <factor> --> <const> 
68: <factor> --> <lvalue> 
69: <factor> --> LPAREN <expr> RPAREN 
70: <const> --> INTLIT 
71: <const> --> FLOATLIT 
72: <expr-list> --> NULL 
73: <expr-list> --> <expr> <expr-list-tail> 
74: <expr-list-tail> --> COMMA <expr> <expr-list-tail> 
75: <expr-list-tail> --> NULL 
76: <lvalue> --> ID lvalue-tail 
77: <lvalue-tail> --> NULL 
78: <lvalue-tail> --> LBRACK <expr> RBRACK 



PARSING TABLE:
<expr-tail>:
(RBRACK, rule 50), (RPAREN, rule 50), (DO, rule 50), (THEN, rule 50), (TO, rule 50), (AND, rule 48), (COMMA, rule 50), (SEMI, rule 50), (OR, rule 49), 
===============
<param>:
(ID, rule 27), 
===============
<id-list>:
(ID, rule 15), 
===============
<not_id_expr_start>:
(CONST, rule 43), (LPAREN, rule 44), 
===============
<type>:
(FLOAT, rule 9), (INT, rule 9), (ID, rule 11), (ARRAY, rule 10), 
===============
<Bterm>:
(INTLIT, rule 59), (FLOATLIT, rule 59), (ID, rule 59), (LPAREN, rule 59), 
===============
<expr_not_starting_with_id>:
(CONST, rule 42), (LPAREN, rule 42), 
===============
<stat-tail>:
(ID, rule 41), (CONST, rule 40), (LPAREN, rule 40), 
===============
<expr_or_func_tail>:
(LBRACK, rule 46), (LPAREN, rule 45), 
===============
<stat-seq-tail>:
(ENDIF, rule 29), (FOR, rule 30), (ENDDO, rule 29), (WHILE, rule 30), (END, rule 29), (ID, rule 30), (BREAK, rule 30), (LET, rule 30), (IF, rule 30), (ELSE, rule 29), (RETURN, rule 30), 
===============
<const>:
(INTLIT, rule 70), (FLOATLIT, rule 71), 
===============
<type-declaration-list>:
(VAR, rule 2), (IN, rule 2), (TYPE, rule 3), 
===============
<Cterm>:
(INTLIT, rule 63), (ID, rule 63), (FLOATLIT, rule 63), (LPAREN, rule 63), 
===============
<param-list>:
(RPAREN, rule 21), (ID, rule 22), 
===============
<param-list-tail>:
(RPAREN, rule 23), (COMMA, rule 24), 
===============
<Bterm-tail>:
(RBRACK, rule 62), (RPAREN, rule 62), (GREATER, rule 62), (LESSER, rule 62), (NEQ, rule 62), (THEN, rule 62), (TO, rule 62), (COMMA, rule 62), (OR, rule 62), (DO, rule 62), (PLUS, rule 60), (LESSEREQ, rule 62), (EQ, rule 62), (MINUS, rule 61), (AND, rule 62), (SEMI, rule 62), (GREATEREQ, rule 62), 
===============
<factor>:
(INTLIT, rule 67), (ID, rule 68), (FLOATLIT, rule 67), (LPAREN, rule 69), 
===============
<funct-declaration>:
(FUNC, rule 20), 
===============
<optional-init>:
(SEMI, rule 18), (ASSIGN, rule 19), 
===============
<stat>:
(FOR, rule 33), (WHILE, rule 32), (ID, rule 37), (BREAK, rule 34), (LET, rule 36), (IF, rule 31), (RETURN, rule 35), 
===============
<Cterm-tail>:
(RBRACK, rule 66), (RPAREN, rule 66), (GREATER, rule 66), (LESSER, rule 66), (NEQ, rule 66), (THEN, rule 66), (TO, rule 66), (COMMA, rule 66), (OR, rule 66), (DO, rule 66), (PLUS, rule 66), (LESSEREQ, rule 66), (MINUS, rule 66), (EQ, rule 66), (DIV, rule 65), (MULT, rule 64), (AND, rule 66), (SEMI, rule 66), (GREATEREQ, rule 66), 
===============
<Aterm>:
(INTLIT, rule 51), (FLOATLIT, rule 51), (ID, rule 51), (LPAREN, rule 51), 
===============
<Aterm-tail>:
(RBRACK, rule 58), (RPAREN, rule 58), (DO, rule 58), (NEQ, rule 53), (LESSER, rule 54), (GREATER, rule 55), (THEN, rule 58), (LESSEREQ, rule 56), (EQ, rule 52), (AND, rule 58), (TO, rule 58), (COMMA, rule 58), (SEMI, rule 58), (OR, rule 58), (GREATEREQ, rule 57), 
===============
<var-declaration-list>:
(VAR, rule 5), (IN, rule 4), (FUNC, rule 4), 
===============
<stat-seq>:
(FOR, rule 28), (WHILE, rule 28), (ID, rule 28), (BREAK, rule 28), (LET, rule 28), (IF, rule 28), (RETURN, rule 28), 
===============
<ret-type>:
(COLON, rule 26), (BEGIN, rule 25), 
===============
<var-declaration>:
(VAR, rule 14), 
===============
<lvalue>:
(ID, rule 76), 
===============
<lvalue-tail>:
(LBRACK, rule 78), (DIV, rule 77), (MULT, rule 77), 
===============
<tiger-program>:
(LET, rule 0), 
===============
<declaration-segment>:
(IN, rule 1), (TYPE, rule 1), 
===============
<type-declaration>:
(TYPE, rule 8), 
===============
<funct-declaration-list>:
(IN, rule 6), (FUNC, rule 7), 
===============
<type-id>:
(INT, rule 12), (FLOAT, rule 13), 
===============
<expr-list>:
(RPAREN, rule 72), (INTLIT, rule 73), (ID, rule 73), (FLOATLIT, rule 73), (LPAREN, rule 73), 
===============
<expr>:
(INTLIT, rule 47), (FLOATLIT, rule 47), (ID, rule 47), (LPAREN, rule 47), 
===============
<stat-id>:
(LPAREN, rule 38), (ASSIGN, rule 39), 
===============
<expr-list-tail>:
(RPAREN, rule 75), (COMMA, rule 74), 
===============
<id-list-tail>:
(COLON, rule 17), (COMMA, rule 16), 
===============
